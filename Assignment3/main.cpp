//
//  main.cpp
//  Assignment1VS
//
//  Created by Michael Frick on 07/10/15.
//  Copyright Â© 2015 FricknMike. All rights reserved.
//

#include <opencv2/opencv.hpp>
#include "VideoLoader.hpp"
#include "BgModel.hpp"

using namespace cv;
using namespace std;

// main
int main(int argc, const char * argv[]) {

    // vars
    Mat* previousFrame = new Mat;
    Mat* firstFrame = new Mat;
    Mat* frame = new Mat;
    
    int width = 320;
    int height = 180;
    
    Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
    
    int fps = 25;
    double wait = 1000.0/fps;
    
    for(int i = 0; i < 1; i++) {
        VideoCapture* video = loadVideo(i);

        Mat* movingStuff = new Mat(Size(width, height), CV_8U);

        while(video[0].isOpened()) {
            if(video[0].read(*frame) != false) {
                resize(*frame, *frame, Size(width, height), 0, 0, INTER_CUBIC);
                ////////////
                Mat* blurredFrame = new Mat;
                GaussianBlur(*frame, *blurredFrame, Size( 15, 15), 0, 0 );
                
                unsigned int currentFrameNo = video[0].get(CAP_PROP_POS_FRAMES);
                
                if(currentFrameNo == 1) {
                    *firstFrame = blurredFrame->clone();
                }
                else {
                    
                    if(currentFrameNo == 450) {
                        for(int r = 0; r < movingStuff->rows; r++) {
                            for(int c = 0; c < movingStuff->cols; c++) {
                                
                                movingStuff->at<uchar>(r,c) =0;
                                *firstFrame = blurredFrame->clone();
                            }
                        }
                    }

                    moveWindow("lastFrame", 0, 0);
                    
                    imshow("currentFrame", *frame);
                    moveWindow("currentFrame", 0, firstFrame->rows + 50);
                    



                    //update the background model
                    pMOG2->apply(*blurredFrame, fgMaskMOG2, 0.0005);
                    
                    Mat* threshImg = new Mat;
                    threshold(fgMaskMOG2, *threshImg, 150, 255, THRESH_BINARY);
                    
                    
                    
                    if(currentFrameNo > 2 && currentFrameNo % 2 == 0) {
                        for(int r = 0; r < movingStuff->rows; r++) {
                            for(int c = 0; c < movingStuff->cols; c++) {
                                
                                if(threshImg->at<uchar>(r,c) == 255) {
                                    int currentPixlVal = movingStuff->at<uchar>(r,c);
                                    
                                    if(threshImg->at<uchar>(r,c) == previousFrame->at<uchar>(r,c)) {
                                        if(currentPixlVal < 254) {
                                            movingStuff->at<uchar>(r,c) +=2;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    
                    imshow("lets see", *movingStuff);
                    
                    Mat* threshIt = new Mat;
                    threshold(*movingStuff, *threshIt, 130, 255, THRESH_BINARY);
                    
                    imshow("lets asdsa", *threshIt);
                    

                    ////////////////CONTOURS START
                    vector<vector<Point> > contours;

                    // find the contours
                    findContours(*threshIt, contours, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);

                    vector<vector<Point> > contours_poly( contours.size() );
                    vector<Point2f>center( contours.size() );
                    vector<float>radius( contours.size() );

                    for( int ii = 0; ii < contours.size(); ii++ ){
                        approxPolyDP( Mat(contours[ii]), contours_poly[ii], 3, true );
                        minEnclosingCircle( (Mat)contours_poly[ii], center[ii], radius[ii] );
                    }

                    
                    Mat* newObjects = new Mat[center.size()];
                    
                    for(int i = 0; i < center.size(); i++) {
                        if(radius[i] > 2) {
                            circle(*frame, center[i], radius[i], Scalar(160, 0, 255));
                        }
                        
                        moveWindow("threshIt", 500, 100);
                        
                        
                        //////////////
                        imshow("circles", *frame);
                        
                        Rect roi = Rect(center[i].x - 2* radius[i], center[i].y - 2* radius[i], 4*radius[i], 4*radius[i]);

                        
                        Mat image = *frame;
                        
                        newObjects[i] = image(roi).clone();
                        
                       
                        
                        Mat* canny = new Mat;
                        Canny(newObjects[i], *canny, 100, 255);
                        
                         imshow("asdas", *canny);
                    }
                    
                    *previousFrame = threshImg->clone();
                    /////////////////////////

                }

                
                
                /*** video controls ***/
                int key = waitKey(wait);

                // video control
                switch(key) {
                case 32:
                    if (fps != 0) {
                        cout << "paused" << endl;
                        fps = 0;
                    }
                    else {
                        cout << "play" << endl;
                        fps = wait;
                    }
                    break;
                case 63234:
                    cout << "<<" << endl;
                    if(wait <= 200) {
                        wait += 10;
                    }
                    break;
                case 63235:
                    cout << ">>" << endl;
                    if(wait >= 10) {
                        wait -= 10;
                    }
                    else {
                        wait = 1;
                    }
                    break;
                }
            }
        }
    }
    
    
    cout << "press any key to end the programm" << endl;
    waitKey(0);

    return 0;
}
